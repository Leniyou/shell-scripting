#!/bin/bash
#
# -- Process management script -- #
# One of our systems has a service that exits randomly.
# We know this is a common issue but the maintainers of 
# the service stated they wont resolve this issue any 
# time soon since it is only affecting some users (edge
# case) and workarounds can be implemented outside the
# source code of the service. Thus, we shall implement a
# workaround for us.
# 
# The DevOps manager has requested you to design a script 
# that will check if the process is up and perform some 
# task if it s not. The specific requirements are:
# 
# - Exists automatically if an error is found.
# - The script should be place as a cronjob for the root user.
# - The script should log whether the service is up, down, or 
# started if it was down.
# - The log file path should be configured using a variable.
# - Log useful comments and data at each step.
# - The target service should be configured using a variable 
# (so if we want to change the target process, we can do it by
# simply changing the name of the variable)
# --

# -- Let's set some global variables -- #
SCRIPT_NAME=$(basename "$0")	      # Script name 
USER=$(whoami)					            # To get the user who is running the script
FULL_PATH=$(pwd)				            # To get full path where the script is
MESSAGE_LOG=""                      # Variable to store debug log message
ERROR_LOG=""                        # Variable to store error log message
RECOMM_LOG=""                       # Variable to store recommendation log message 

# -- The log file path should be configured using a variable -- #
LOG_DIR="${FULL_PATH}/logs"			   
# --
# The target service should be configured using a variable
# if you change the target service, please make sure to add
# .service at the end in order to this script to work
# --
TARGET_SERVICE="httpd.service"			
# -- Variable for log file name. e.g.: httpd.service-2022-09-30.log  --#
SERVICE_LOG_FILE="${TARGET_SERVICE}-$(date +'%F').log"

#######################################
# Description:
#   Function to error catching
#   Redirects output to STDERR
# Globals:
#   USER
# Locals:
#   ERROR
#   RECOMM
# Arguments:
#   Error message to be printed
#   A brief recommendation to avoid the error
# Outputs:
#   output will printed on terminal:
#   [2023-02-02 10:28:43]:
#   - message error -
#   - recommendation - 
#######################################
function err() {
  local ERROR="$1"

  local RECOMM="$2"
  echo -e "
    [$(date +'%F %H:%M:%S')]:
    Username: ${USER}
    Error: ${ERROR}
    Recommendation: ${RECOMM}
    Exit status: 1
  " >&2 
}

#######################################
# Description:
#   Function to store logs into debug.log file
#   Logs generated by tasks ran by the script
# Globals:
#   USER
# Locals:
#   MESSAGE
# Arguments:
#   Message log to be store
#######################################
function to_debug_log() {
  local MESSAGE="$1"
  # Logs for debugging stored in debug.log file
  (
    printf "\nDate: %s\n" "$(date)"
    printf "Username: %s\n" "${USER}"
    printf "Message:"
    printf " %s " "${MESSAGE}"
  ) >> debug.log
}
# -- 
# To create log directory and debug.log file
# mkdir -p option is to override directory if it is already created
# --
mkdir -p "${LOG_DIR}" && touch "${LOG_DIR}/debug.log"

if [[ -d "${LOG_DIR}" ]]; then
  cd "${LOG_DIR}" || exit
  # Logs for debugging stored in debug.log file
  MESSAGE_LOG="
    Log directory created successfully\n
    ${LOG_DIR}
  "
  to_debug_log "${MESSAGE_LOG}"
else
  # -- printing errors -- #
  ERROR_LOG="
    Unable to create log directory:
    ${LOG_DIR}
  "
  RECOMM_LOG="
    Please check if you have proper permissions in the selected folder:
    ${FULL_PATH}
  "
  err "${ERROR_LOG}" "${RECOMM_LOG}" 
  exit 1
fi
# --
# Then, script will create httpd.service-2022-09-30.log file
# for logging information about selected target service
# --
if touch "${SERVICE_LOG_FILE}";
then
  # Logs for debugging stored in debug.log file
  MESSAGE_LOG="
    Log file ${SERVICE_LOG_FILE}
    created successfully in the selected folder: 
    ${LOG_DIR}
  "
  to_debug_log "${MESSAGE_LOG}"
else
  # -- printing errors -- #
  ERROR_LOG="
    Unable to create file
    ${SERVICE_LOG_FILE}
  "
  RECOMM_LOG="
    Please check if you have proper permissions in the selected folder:
    ${LOG_DIR}
  "
  err "${ERROR_LOG}" "${RECOMM_LOG}" 
  exit 1
fi
# Logs for debugging stored in debug.log file
MESSAGE_LOG="
  ${TARGET_SERVICE} has been selected as the target service.
   Running => systemctl list-unit-files | grep -q ${TARGET_SERVICE}
   to check if the service is enabled or installed on this workstation
"
# -- Script now will check if selected service is enabled or installed on this machine -- #
if ! systemctl list-unit-files | grep -q "${TARGET_SERVICE}"
then
  # -- If selected service is not installed or enabled -- #
  # -- printing errors -- #
  ERROR_LOG="The selected service ${TARGET_SERVICE} is not installed or enabled on this workstation."
  RECOMM_LOG="further information can be found in ${LOG_DIR}/debug.log file"
  err "${ERROR_LOG}" "${RECOMM_LOG}"
  # -- Log message with further information -- #
  MESSAGE_LOG+="
    Target service is not installed or enabled on this workstation.
    Command systemctl list-unit-files | grep -q ${TARGET_SERVICE} returned code 1,
    it means that the ${TARGET_SERVICE} is not installed or is not enabled on
    this workstation. Please spell check the service name you just typed or verify
    the list of installed services running the next command:
    systemctl --all --type service
    Exit status: 1
  "
  to_debug_log "${MESSAGE_LOG}"
  # Exit script
  exit 1
else
  # -- If selected service is installed or enabled -- #
  MESSAGE_LOG+="
    Service is enabled/installed on this workstation.
    Running => systemctl show -p SubState --value ${TARGET_SERVICE}
    to check if service is Up/Started.
  "
  # -- Now script will check if service is UP/Running -- #
  if [[ $(systemctl show -p SubState --value "${TARGET_SERVICE}") != "running" ]]	
  then
    # -- If service is not running -- #
    MESSAGE_LOG+="The ${TARGET_SERVICE} is Stopped/Inactive (dead)."  
  else
    # -- If service is running -- #
    MESSAGE_LOG+="The ${TARGET_SERVICE} is Runinng/Active."
  fi
  # -- Logs for debugging stored in debug.log file -- #
  to_debug_log "${MESSAGE_LOG}"
fi
# -- To start logging target service status -- #
ACTIVE_STATUS=$(systemctl status "${TARGET_SERVICE}" | grep "Active")
MAIN_PID=$(systemctl status "${TARGET_SERVICE}" | grep "Main PID")
LOGS=$(systemctl status --no-pager -l "${TARGET_SERVICE}" | grep "systemd")

# -- Logs for debugging saved in debug.log file -- #
printf "\nStarting gathering status information about the %s\n" "${TARGET_SERVICE}"
printf "Running: \n"
printf "  => systemctl status %s ${TARGET_SERVICE} | grep 'Active' to get service status\n"
printf "  => systemctl status %s ${TARGET_SERVICE} | grep 'Main PID' to get service main process ID\n"
printf "  => systemctl status --no-pager -l %s ${TARGET_SERVICE} | grep 'systemd' to get service additional information\n"

# Logs for logging saved in service log file
# Logging information about the selected service
printf "\nDate: %s\n" "$(date)"
printf "Username: %s\n" "${USER}"
printf "Service name: %s\n" "${TARGET_SERVICE}"
printf "Active status: %s\n" "${ACTIVE_STATUS}"
printf "Main Process ID: %s\n" "${MAIN_PID}"
printf "Logs:\n"
printf "%s\n" "${LOGS}"

## To add this script as a cronjob on crontab ##
# awk '!x[$0]++' parameter removes duplicate lines from text input without pre-sorting,
# everytime the script is added to crontab, it will be added as a new line, this parameter
# avoid to duplicate that entry in the cronjob file.
# Add SHELL to crontab
(crontab -l; echo "SHELL=/bin/bash") | awk '!x[$0]++' | crontab -
# Add PATH to crontab
(crontab -l; echo "PATH=/sbin:/bin:/usr/sbin:/usr/bin") | awk '!x[$0]++' | crontab -
# Add this script to crontab to run every 5 minutes
(crontab -l; echo "# To monitor target service ${TARGET_SERVICE}") | crontab -
(crontab -l; echo "*/1 * * * * $FULL_PATH/$SCRIPT_NAME >> ${LOG_DIR}/${SERVICE_LOG_FILE} 2>&1") | awk '!x[$0]++' | crontab -

# -- Logs for debugging saved in debug.log file -- #
MESSAGE_LOG="
  Adding this script ./${SCRIPT_NAME} as a cronjob.
  To run every 5 minutes and gather information about the %s ${TARGET_SERVICE}.
"
to_debug_log "${MESSAGE_LOG}"
